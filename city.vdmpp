class City is subclass of GLOBAL

-- The City is a collection of RoadSegments and Intersections
-- See it as a graph
--      Each intersection is a node in the graph
--      Each road is an edge in the graph

instance variables
    public intersections : set of Intersection; -- graph nodes
    public roads : set of RoadSegment; -- graph edges
    public road_to_intersections : RoadGraph; -- graph
    public intersection_to_roads : IntersectionGraph; -- graph
    -- costs : seq of real; -- something something adjacency matrix with dsitances as costs.    

functions
    -- private make_road_ids : set of Edge -> RoadGraph
    -- make_road_ids(p_edges) ==
    --     let make_road_ids_rec = lambda p_edges_rec : set of Edge, p_id : RoadID &
    --         if p_edges_rec = {} then
    --             { |-> }
    --         else
    --             let edge in set p_edges_rec in
    --                 let rest = make_road_ids_rec(p_edges_rec \ {edge}, p_id + 1) in
    --                     rest ++ {p_id |-> edge} in
    --         make_road_ids_rec(p_edges, 0);

    private make_road_graph : set of Edge -> RoadGraph
    make_road_graph(p_edges) ==
        make_road_graph_rec(p_edges, 0);

    private make_road_graph_rec : set of Edge * RoadID -> RoadGraph
    make_road_graph_rec(p_edges_rec, p_id) ==
        if p_edges_rec = {} then
            { |-> }
        else
            let edge in set p_edges_rec in
                let rest = make_road_graph_rec(p_edges_rec \ {edge}, p_id + 1) in
                    rest ++ {p_id |-> edge}
                    -- let mk_(intersection1, intersection2) = edge in
    measure card p_edges_rec;

    -- infer map from Intersections to Roads from map from Roads to Intersections
    private make_intersection_graph : set of IntersectionID * RoadGraph -> IntersectionGraph
    make_intersection_graph(p_intersection_ids, p_road_to_intersections) ==
        {
            intersection_id |-> {
                road_id
                | road_id in set dom p_road_to_intersections &
                    let edge = p_road_to_intersections(road_id) in
                        edge.intersection1 = intersection_id or edge.intersection2 = intersection_id
            }
            | intersection_id in set p_intersection_ids
        };
    

operations
    -- make roads from RoadGraph
    private make_roads : RoadGraph * seq of Position ==> set of RoadSegment
    make_roads(p_road_to_intersections, p_intersection_positions) ==
        return {
            new RoadSegment(
                road_id,
                p_intersection_positions(p_road_to_intersections(road_id).intersection1),
                p_intersection_positions(p_road_to_intersections(road_id).intersection2)
            )
            | road_id in set dom p_road_to_intersections
        };
    
    -- make intersections from IntersectionGraph
    private make_intersections : seq of Position ==> set of Intersection
    make_intersections(p_intersection_positions) ==
        return {
            new Intersection(
                intersection_id,
                p_intersection_positions(intersection_id),
                {
                    road
                    | road in set roads & road.ID in set intersection_to_roads(intersection_id)
                }
            )
            | intersection_id in set dom intersection_to_roads
        };

    -- constructor
    -- takes a sequence of positions, that define the placement of intersections
    -- along with the index for the each position as the intersection id
    -- takes a set of edges which describes which
    -- intersection ids (indices in the sequence) are connected
    City : seq of Position * set of Edge ==> City
    City(p_intersection_positions, p_edges) == (
        -- make the graph representation of the city with maps
        road_to_intersections := make_road_graph(p_edges);
        intersection_to_roads := make_intersection_graph(inds p_intersection_positions, road_to_intersections);
        
        -- instantiate the roads and intersections
        -- question: convention
        --           should these operations set the instance variables themselves?
        roads := make_roads(road_to_intersections, p_intersection_positions);
        intersections := make_intersections(p_intersection_positions);
    );

    -- add a car to the city
    -- takes a position of an intersection
    -- use intersection to find the a road to start on
    public add_car : Car * Position ==> ()
    add_car(p_car, p_intersection_position) == (
        -- 1. find the intersection
        -- 2. choose random road from intersection
        -- 3. add car to road
        let intersection in set intersections
        be st intersection.position = p_intersection_position in
            let road in set intersection.connections in
                road.add_car(p_car);
    );

    public step : () ==> ()
    step() == (
        -- 1. move the cars
        --    1.1. if car reaches intersection, move it to the next road
        --    1.2. if car reaches an intersection with no new road to move to, remove it
        -- 2. sense cars
        -- 3. turn street lamps on or off
        let cars = dunion {
            road.get_cars()
            | road in set roads
        } in
            for all car in set cars do (
                dcl velocity : real := car.velocity,
                    road : RoadSegment := car.road,
                    progress : real := car.progress,
                    direction : int := car.direction;
                
                -- update car position
                let updated_progress =
                progress + velocity * World`timerRef.step_length in
                    if abs(updated_progress) >= road.get_length() then
                        -- let at_intersection = 
                        skip;
            );

        let street_lamps = dunion {road.street_lamps | road in set roads} in
            let sensors = {
                street_lamp.sensor
                | street_lamp in set street_lamps
            } in
                for all sensor in set sensors do
                    sensor.sense();
    );

end City